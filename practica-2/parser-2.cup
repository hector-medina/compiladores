import java_cup.runtime.*;
import java.io.*;
import java.time.LocalDate;

parser code {:

    // --- COMPILERS -- UNIVERSITAT OBERTA DE CATALUNYA
    // --- Activity 2 - Syntactic analysis analysis
    //
    // STUDENT FULL NAME:
    // UOC USERNAME:
    // COURSE INSTRUCTOR:

    // Add any attributes to the parser (if you need them) here


    // Add any code that you would like to execute before the parser begins
    // Here you can initialize any variables you require
    // There is no need to modify this funcion if you don't need it!
    public static void initParser() {

    }

    // Add any code that you would like to execute after the parser ends
    // There is no need to modify this function if you don't need it!
    public static void endParser() {


    }


:}

terminal DATASET, PREPARATION, COLUMN, FEATURE, DELETE, BOOLEAN, INT, FLOAT, STRING, DATE;
terminal AND, OR, NOT, DIV, IF, THEN, ELSE, END, TRUE, FALSE, TODAY;
terminal EQ, NEQ, LT, GT, LEQ, GEQ, PLUS, MINUS, TIMES, NEG;
terminal OPEN_KEY, CLOSE_KEY, OPEN_PAREN, CLOSE_PAREN, COMMA, COLON;
terminal String  IDENT;
terminal LocalDate DATE_LITERAL;
terminal Float   FLOAT_LITERAL;
terminal Integer INT_LITERAL;
terminal String  STRING_LITERAL;

non terminal file;
non terminal dataset;
non terminal column;
non terminal type;
non terminal preparation;
non terminal delete_if;
non terminal delete_column;
non terminal feature;
non terminal expression;
non terminal constant;
non terminal function;
non terminal boolean;
non terminal arithmetic;
non terminal arithmetic_op;
non terminal relational;
non terminal relational_op;
non terminal conditional;

file ::= 
    DATASET IDENT:id OPEN_KEY dataset CLOSE_KEY {: Eval.emitDatasetDecl(id.toString ()); :} | 
    DATASET IDENT:id OPEN_KEY dataset CLOSE_KEY {: Eval.emitDatasetDecl(id.toString ()); :} file
  ;


dataset ::= 
    |
    PREPARATION OPEN_KEY preparation CLOSE_KEY {: Eval.emitPreparation(); :} |
    COLUMN column {: Eval.emitColumnDecl(); :}  dataset 
  ;

// Columnas del dataset.
column ::= 
    IDENT COLON type |
    IDENT COMMA column
  ;

// Tipos de datos en columnas
type ::= 
    BOOLEAN |
    INT |
    FLOAT |
    STRING |
    DATE
  ;

// Preparación del dataset, elimina filas o columnas y añade características.
preparation ::=
    |
    DELETE IF delete_if {: Eval.emitDeleteIfCmd(); :} preparation |
    DELETE COLUMN delete_column {: Eval.emitDeleteColumnCmd(); :} preparation |
    FEATURE IDENT:id COLON feature {: Eval.emitFeature(id.toString()); :} preparation
  ;

delete_if ::= 
    TRUE  {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :} |
    TRUE AND NOT IDENT {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :} |
    IDENT PLUS INT_LITERAL TIMES INT_LITERAL GEQ  INT_LITERAL {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :} |
    INT_LITERAL  {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :}
  ;

delete_column ::= 
    IDENT |
    IDENT COMMA delete_column
  ;

feature ::=
    type EQ expression {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :} |
    type EQ expression MINUS DATE_LITERAL  {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :} |
    type EQ IDENT GEQ IDENT DIV STRING_LITERAL {: Eval.emitSubexpression(Eval.Subexpression.LITERAL); :} |
    type EQ IF FALSE THEN IF IDENT THEN IDENT ELSE IDENT END ELSE TODAY END {: Eval.emitSubexpression(Eval.Subexpression.IFTHENELSE); :} 
  ;

expression ::= 
    constant |
    IDENT |
    function |
    boolean |
    arithmetic |
    relational |
    conditional 
  ;



constant ::=
    TRUE |
    FALSE |
    TODAY |
    DATE_LITERAL |
    INT_LITERAL |
    FLOAT_LITERAL |
    STRING_LITERAL
  ;

function ::=
    IDENT OPEN_PAREN IDENT CLOSE_PAREN
  ;


boolean ::= 
    NOT IDENT |
    IDENT AND IDENT |
    IDENT OR IDENT
  ;

arithmetic ::=
    MINUS INT_LITERAL |
    MINUS INT_LITERAL arithmetic_op INT_LITERAL  |
    IDENT arithmetic_op IDENT  
  ;

arithmetic_op ::=
    PLUS |
    TIMES |
    DIV |
    MINUS
  ;

relational ::=
    IDENT relational_op IDENT 
  ;

relational_op ::=
    EQ |
    NEQ |
    LT |
    GT |
    LEQ |
    GEQ
  ;

conditional ::= 
    IF expression THEN expression ELSE expression END
  ;
